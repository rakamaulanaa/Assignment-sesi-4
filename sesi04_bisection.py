# -*- coding: utf-8 -*-
"""SESI04_BISECTION

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oDYWcqkbrmBKH9XURHbR19kOvPUz1AVL
"""

import numpy as np

def my_bisection (f, a, b, tol) :
  # approximate a root, R, of f bounded
  # by a and b to within tolerance
  # | f (m) | < tol with m the midpoint
  # between a and b  Recursive implementation

  # check if a and b bound a root
  if np.sign (f(a)) == np.sign (f(b)) :
      raise Exception (
          "The scalars a and b do not bound a root")

  # get midpoint
  m = (a + b) /2

  if np.abs(f(m)) < tol:
      # stopping condition, report m as root
      return m
  elif np.sign(f(a)) == np.sign(f(m)) :
    # case where m is an improvement on a.
    # make recursive call with a = m
    return my_bisection (f, m, b, tol)
  elif np.sign(f(b)) == np.sign(f(m)) :
    # case where m is an improvement on b.
    # make recursive call with b = m
    return my_bisection(f, a, m, tol)

f = lambda x: x**2 - 2

r1 = my_bisection(f, 0, 2, 0.1)
print("r1 =", r1)
r01 = my_bisection(f, 0, 2, 0.01)
print("r01 =", r01)

print ("f(r1) =", f(r1))
print ("f(r01 =)", f(r01))

my_bisection(f, 2, 4, 0.01)

"""QUIZ 1 BISECTION"""

f(x) = x**3 - 3*x**2 + 2*x
(a,b) = (1,2)
tol = 0.01

f = lambda x: x**3 - 3*x**2 + 2*x

r1 = my_bisection(f, 1, 2, 0.01)
print ("r1 =", r1)

print ("f(r1) =", f(r1))

"""Quiz 2 Bisection"""

f(x) = sin(x) - x
(a,b) = (0,1)

tol = 0.001

f = lambda x: np.sin(x) - x

r1 = my_bisection(f, 0, 1, 0.001)
print ("r1 =", r1)

print ("f(r1) =", f(r1))